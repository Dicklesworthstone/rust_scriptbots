use std::collections::HashMap;
use std::fs;
use std::io;
use std::path::PathBuf;
use std::time::{Duration, Instant};

use anyhow::{Context, Result, bail};
use clap::{Parser, Subcommand, ValueEnum};
use crossterm::{
    cursor::{Hide, Show},
    event::{self, Event, KeyCode},
    execute,
    terminal::{EnterAlternateScreen, LeaveAlternateScreen, disable_raw_mode, enable_raw_mode},
};
use csv::Writer;
use duckdb::{Connection, params};
use owo_colors::OwoColorize;
use ratatui::{
    Frame, Terminal,
    backend::CrosstermBackend,
    layout::{Constraint, Direction, Layout},
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::{Block, Borders, Paragraph, Row, Table},
};
use reqwest::Client;
use scriptbots_app::{
    ConfigPatchRequest, ConfigSnapshot, KnobApplyRequest, KnobEntry, KnobKind, KnobUpdate,
};
use serde::de::DeserializeOwned;
use serde_json::Value;

#[derive(Parser, Debug)]
#[command(
    name = "scriptbots-control",
    version,
    about = "Interact with ScriptBots runtime controls via REST"
)]
struct Cli {
    /// Base URL for the running ScriptBots REST control API.
    #[arg(
        long,
        env = "SCRIPTBOTS_CONTROL_URL",
        default_value = "http://127.0.0.1:8080"
    )]
    base_url: String,

    #[command(subcommand)]
    command: Command,
}

#[derive(Subcommand, Debug)]
enum Command {
    /// List all available configuration knobs and their current values.
    List,
    /// Fetch the complete configuration snapshot as JSON.
    Get,
    /// Update a configuration knob by path.
    Set {
        /// Dot-delimited knob path (e.g. world_width or neuroflow.enabled).
        path: String,
        /// New value expressed as JSON (unquoted literal, or a raw string fallback).
        value: String,
    },
    /// Apply a JSON patch object to the configuration.
    Patch {
        /// Optional file to read the JSON patch from; if omitted, read from the CLI arguments.
        #[arg(short, long)]
        file: Option<PathBuf>,
        /// Inline JSON (joined with spaces) when --file is not supplied.
        json: Vec<String>,
    },
    /// Launch an updating TUI dashboard to monitor knobs.
    Watch {
        /// Refresh interval in milliseconds.
        #[arg(long, default_value_t = 500)]
        interval_ms: u64,
    },
    /// Export recent metrics or tick records to CSV from a DuckDB run.
    Export {
        /// Kind of dataset to export.
        #[arg(value_enum)]
        kind: ExportKind,
        /// Path to the DuckDB database file generated by the simulation.
        #[arg(long = "db", value_name = "FILE", default_value = "scriptbots.db")]
        database: PathBuf,
        /// Destination CSV file path (directories created as needed).
        #[arg(long, value_name = "FILE")]
        out: PathBuf,
        /// Limit to the most recent N rows (oldest-first in the output). Omit for full export.
        #[arg(long, value_name = "ROWS")]
        last: Option<usize>,
    },
    /// List available scenario presets.
    Presets,
    /// Apply a preset by name via REST.
    ApplyPreset {
        /// Preset name to apply (see `presets`).
        name: String,
    },
}

#[derive(Copy, Clone, Debug, ValueEnum)]
enum ExportKind {
    Metrics,
    Ticks,
}

#[tokio::main]
async fn main() -> Result<()> {
    let cli = Cli::parse();
    match cli.command {
        Command::Export {
            kind,
            database,
            out,
            last,
        } => export_command(kind, database, out, last)?,
        other => {
            let client = Client::builder()
                .build()
                .context("failed to build HTTP client")?;
            match other {
                Command::List => list_command(&client, &cli.base_url).await?,
                Command::Get => get_command(&client, &cli.base_url).await?,
                Command::Set { path, value } => {
                    set_command(&client, &cli.base_url, path, value).await?
                }
                Command::Patch { file, json } => {
                    patch_command(&client, &cli.base_url, file, json).await?
                }
                Command::Watch { interval_ms } => {
                    run_watch(
                        client.clone(),
                        cli.base_url.clone(),
                        Duration::from_millis(interval_ms),
                    )
                    .await?
                }
                Command::Export { .. } => unreachable!("handled in outer match"),
                Command::Presets => presets_list(&client, &cli.base_url).await?,
                Command::ApplyPreset { name } => presets_apply(&client, &cli.base_url, &name).await?,
            }
        }
    }

    Ok(())
}

fn export_command(
    kind: ExportKind,
    database: PathBuf,
    out: PathBuf,
    last: Option<usize>,
) -> Result<()> {
    if let Some(limit) = last
        && limit == 0
    {
        bail!("--last must be greater than zero when provided");
    }

    if let Some(parent) = out.parent().filter(|p| !p.as_os_str().is_empty()) {
        fs::create_dir_all(parent)
            .with_context(|| format!("failed to create export directory {}", parent.display()))?;
    }

    let connection = Connection::open(&database)
        .with_context(|| format!("failed to open DuckDB database {}", database.display()))?;
    let file = std::fs::File::create(&out)
        .with_context(|| format!("failed to create export file {}", out.display()))?;
    let mut writer = Writer::from_writer(file);

    let written = match kind {
        ExportKind::Metrics => export_metrics(&connection, &mut writer, last)?,
        ExportKind::Ticks => export_ticks(&connection, &mut writer, last)?,
    };

    writer.flush().context("failed to flush CSV writer")?;
    println!(
        "{} {} rows from {} to {}",
        "exported".green().bold(),
        written,
        format!("{:?}", kind).cyan(),
        out.display()
    );

    Ok(())
}

fn export_metrics(
    connection: &Connection,
    writer: &mut Writer<std::fs::File>,
    last: Option<usize>,
) -> Result<usize> {
    let mut records = Vec::new();
    let mut stmt = if last.is_some() {
        connection.prepare(
            "select tick, name, value
             from metrics
             order by tick desc
             limit ?",
        )?
    } else {
        connection.prepare(
            "select tick, name, value
             from metrics
             order by tick desc",
        )?
    };
    let mut rows = if let Some(limit) = last {
        stmt.query(params![limit as i64])?
    } else {
        stmt.query([])?
    };

    while let Some(row) = rows.next()? {
        let tick: i64 = row.get(0)?;
        let name: String = row.get(1)?;
        let value: f64 = row.get(2)?;
        records.push((tick, name, value));
    }
    records.reverse();

    writer
        .write_record(["tick", "name", "value"])
        .context("failed to write metrics header")?;
    for (tick, name, value) in &records {
        writer.write_record([tick.to_string(), name.clone(), format!("{value:.6}")])?;
    }

    Ok(records.len())
}

fn export_ticks(
    connection: &Connection,
    writer: &mut Writer<std::fs::File>,
    last: Option<usize>,
) -> Result<usize> {
    let mut records = Vec::new();
    let mut stmt = if last.is_some() {
        connection.prepare(
            "select tick, epoch, closed, agent_count, births, deaths, total_energy, average_energy, average_health
             from ticks
             order by tick desc
             limit ?",
        )?
    } else {
        connection.prepare(
            "select tick, epoch, closed, agent_count, births, deaths, total_energy, average_energy, average_health
             from ticks
             order by tick desc",
        )?
    };
    let mut rows = if let Some(limit) = last {
        stmt.query(params![limit as i64])?
    } else {
        stmt.query([])?
    };

    while let Some(row) = rows.next()? {
        let tick: i64 = row.get(0)?;
        let epoch: i64 = row.get(1)?;
        let closed: bool = row.get(2)?;
        let agent_count: i64 = row.get(3)?;
        let births: i64 = row.get(4)?;
        let deaths: i64 = row.get(5)?;
        let total_energy: f64 = row.get(6)?;
        let average_energy: f64 = row.get(7)?;
        let average_health: f64 = row.get(8)?;
        records.push((
            tick,
            epoch,
            closed,
            agent_count,
            births,
            deaths,
            total_energy,
            average_energy,
            average_health,
        ));
    }
    records.reverse();

    writer
        .write_record([
            "tick",
            "epoch",
            "closed",
            "agent_count",
            "births",
            "deaths",
            "total_energy",
            "average_energy",
            "average_health",
        ])
        .context("failed to write tick header")?;
    for record in &records {
        writer.write_record([
            record.0.to_string(),
            record.1.to_string(),
            record.2.to_string(),
            record.3.to_string(),
            record.4.to_string(),
            record.5.to_string(),
            format!("{:.6}", record.6),
            format!("{:.6}", record.7),
            format!("{:.6}", record.8),
        ])?;
    }

    Ok(records.len())
}

async fn list_command(client: &Client, base_url: &str) -> Result<()> {
    let knobs: Vec<KnobEntry> = fetch_knobs(client, base_url).await?;
    if knobs.is_empty() {
        println!("{}", "No knobs reported by the control API".yellow());
        return Ok(());
    }

    let mut knobs = knobs;
    knobs.sort_by(|a, b| a.path.cmp(&b.path));

    println!(
        "{:<54} {:<10} {}",
        "PATH".bold().cyan(),
        "TYPE".bold().cyan(),
        "VALUE".bold().cyan()
    );
    println!("{}", "-".repeat(96).dimmed());

    for entry in knobs {
        println!(
            "{:<54} {:<10} {}",
            entry.path.bold(),
            knob_kind_label(entry.kind).italic().blue(),
            value_to_string(&entry.value, 32)
        );
    }

    Ok(())
}

async fn get_command(client: &Client, base_url: &str) -> Result<()> {
    let snapshot: ConfigSnapshot = fetch_config(client, base_url).await?;
    let pretty = serde_json::to_string_pretty(&snapshot.config)
        .context("failed to format configuration JSON")?;
    println!("{} {}", "tick".green().bold(), snapshot.tick);
    println!("{}", pretty.cyan());
    Ok(())
}

async fn set_command(
    client: &Client,
    base_url: &str,
    path: String,
    raw_value: String,
) -> Result<()> {
    let value = parse_value(&raw_value)?;
    let request = KnobApplyRequest {
        updates: vec![KnobUpdate {
            path: path.clone(),
            value: value.clone(),
        }],
    };
    let snapshot: ConfigSnapshot = apply_updates(client, base_url, &request).await?;
    let resolved = snapshot
        .config
        .pointer(&json_pointer(&path))
        .cloned()
        .unwrap_or(Value::Null);
    println!(
        "{} {} => {}",
        "updated".green().bold(),
        path,
        value_to_string(&resolved, 48)
    );
    Ok(())
}

async fn patch_command(
    client: &Client,
    base_url: &str,
    file: Option<PathBuf>,
    inline: Vec<String>,
) -> Result<()> {
    let patch_value = if let Some(path) = file {
        let data = std::fs::read_to_string(&path)
            .with_context(|| format!("failed to read patch file {}", path.display()))?;
        serde_json::from_str::<Value>(&data)
            .with_context(|| format!("patch file {} did not contain valid JSON", path.display()))?
    } else {
        let joined = inline.join(" ");
        if joined.trim().is_empty() {
            bail!("provide either --file or inline JSON patch arguments");
        }
        serde_json::from_str::<Value>(&joined)
            .context("inline patch arguments were not valid JSON")?
    };

    if !patch_value.is_object() {
        bail!("patch payload must be a JSON object");
    }

    let body = ConfigPatchRequest { patch: patch_value };
    let snapshot: ConfigSnapshot = apply_patch(client, base_url, &body).await?;
    println!("{}", "Configuration patch applied".green().bold());
    println!("tick {}", snapshot.tick);
    Ok(())
}

async fn run_watch(client: Client, base_url: String, interval: Duration) -> Result<()> {
    tokio::task::spawn_blocking(move || watch_blocking(client, base_url, interval)).await??;
    Ok(())
}

fn watch_blocking(client: Client, base_url: String, interval: Duration) -> Result<()> {
    enable_raw_mode().context("failed to enable raw mode")?;
    let mut stdout = io::stdout();
    execute!(stdout, EnterAlternateScreen, Hide).context("failed to enter alternate screen")?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend).context("failed to create terminal")?;
    let _cleanup = TerminalCleanup;

    let handle = tokio::runtime::Handle::current();
    let mut previous: HashMap<String, Value> = HashMap::new();
    let mut rows: Vec<WatchRow> = Vec::new();
    let mut last_error: Option<String> = None;
    let mut last_refresh = Instant::now() - interval;

    loop {
        if last_refresh.elapsed() >= interval {
            match handle.block_on(fetch_knobs(&client, &base_url)) {
                Ok(entries) => {
                    rows = build_rows(&entries, &previous);
                    previous = entries
                        .into_iter()
                        .map(|entry| (entry.path, entry.value))
                        .collect();
                    last_error = None;
                }
                Err(err) => {
                    last_error = Some(err.to_string());
                }
            }
            last_refresh = Instant::now();
        }

        terminal
            .draw(|frame| draw_watch(frame, &rows, last_error.as_deref(), interval))
            .context("failed to draw watch UI")?;

        let event_ready =
            event::poll(Duration::from_millis(100)).context("failed to poll terminal events")?;
        if event_ready
            && let Event::Key(key) = event::read().context("failed to read terminal event")?
        {
            match key.code {
                KeyCode::Char('q') | KeyCode::Esc => break,
                KeyCode::Char('r') => {
                    // Force refresh on demand.
                    last_refresh = Instant::now() - interval;
                }
                _ => {}
            }
        }
    }

    terminal.show_cursor().ok();
    Ok(())
}

fn build_rows(entries: &[KnobEntry], previous: &HashMap<String, Value>) -> Vec<WatchRow> {
    let mut rows = Vec::with_capacity(entries.len());
    for entry in entries {
        let changed = previous
            .get(&entry.path)
            .map(|value| value != &entry.value)
            .unwrap_or(true);
        rows.push(WatchRow {
            path: entry.path.clone(),
            kind: entry.kind.clone(),
            value: entry.value.clone(),
            changed,
        });
    }
    rows.sort_by(|a, b| a.path.cmp(&b.path));
    rows
}

fn draw_watch(frame: &mut Frame<'_>, rows: &[WatchRow], error: Option<&str>, interval: Duration) {
    let layout = Layout::default()
        .direction(Direction::Vertical)
        .constraints([Constraint::Length(3), Constraint::Min(1)])
        .split(frame.area());

    let mut header_lines = vec![
        Line::from(vec![
            Span::styled(
                "ScriptBots Control Dashboard ",
                Style::default()
                    .fg(Color::Cyan)
                    .add_modifier(Modifier::BOLD),
            ),
            Span::raw("(press 'q' to quit, 'r' to refresh)"),
        ]),
        Line::from(Span::styled(
            format!("Refresh interval: {} ms", interval.as_millis()),
            Style::default().fg(Color::Gray),
        )),
    ];

    if let Some(message) = error {
        header_lines.push(Line::from(Span::styled(
            format!("Last error: {message}"),
            Style::default().fg(Color::Red),
        )));
    }

    let header = Paragraph::new(header_lines).block(Block::default().borders(Borders::ALL));
    frame.render_widget(header, layout[0]);

    if rows.is_empty() {
        let empty = Paragraph::new("Waiting for knob data...")
            .block(Block::default().borders(Borders::ALL));
        frame.render_widget(empty, layout[1]);
        return;
    }

    let table_rows: Vec<Row> = rows
        .iter()
        .map(|row| {
            let style = if row.changed {
                Style::default()
                    .fg(Color::Yellow)
                    .add_modifier(Modifier::BOLD)
            } else {
                Style::default()
            };
            Row::new(vec![
                Span::styled(&row.path, style),
                Span::styled(
                    knob_kind_label(row.kind.clone()),
                    Style::default()
                        .fg(Color::Blue)
                        .add_modifier(Modifier::ITALIC),
                ),
                Span::styled(value_to_string(&row.value, 40), style),
            ])
        })
        .collect();

    let table = Table::new(
        table_rows,
        [
            Constraint::Percentage(45),
            Constraint::Length(12),
            Constraint::Percentage(43),
        ],
    )
    .header(Row::new(vec![
        Span::styled(
            "PATH",
            Style::default()
                .fg(Color::Cyan)
                .add_modifier(Modifier::BOLD),
        ),
        Span::styled(
            "TYPE",
            Style::default()
                .fg(Color::Cyan)
                .add_modifier(Modifier::BOLD),
        ),
        Span::styled(
            "VALUE",
            Style::default()
                .fg(Color::Cyan)
                .add_modifier(Modifier::BOLD),
        ),
    ]))
    .block(Block::default().borders(Borders::ALL))
    .column_spacing(2);

    frame.render_widget(table, layout[1]);
}

struct TerminalCleanup;

impl Drop for TerminalCleanup {
    fn drop(&mut self) {
        let _ = disable_raw_mode();
        let mut stdout = io::stdout();
        let _ = execute!(stdout, LeaveAlternateScreen, Show);
    }
}

#[derive(Clone)]
struct WatchRow {
    path: String,
    kind: KnobKind,
    value: Value,
    changed: bool,
}

async fn fetch_knobs(client: &Client, base_url: &str) -> Result<Vec<KnobEntry>> {
    let url = join_url(base_url, "/api/knobs");
    let response = client
        .get(url)
        .send()
        .await
        .context("failed to fetch knob list")?;
    parse_response(response).await
}

async fn fetch_config(client: &Client, base_url: &str) -> Result<ConfigSnapshot> {
    let url = join_url(base_url, "/api/config");
    let response = client
        .get(url)
        .send()
        .await
        .context("failed to fetch configuration")?;
    parse_response(response).await
}

async fn apply_updates(
    client: &Client,
    base_url: &str,
    request: &KnobApplyRequest,
) -> Result<ConfigSnapshot> {
    let url = join_url(base_url, "/api/knobs/apply");
    let response = client
        .post(url)
        .json(request)
        .send()
        .await
        .context("failed to apply knob updates")?;
    parse_response(response).await
}

async fn apply_patch(
    client: &Client,
    base_url: &str,
    request: &ConfigPatchRequest,
) -> Result<ConfigSnapshot> {
    let url = join_url(base_url, "/api/config");
    let response = client
        .patch(url)
        .json(request)
        .send()
        .await
        .context("failed to apply configuration patch")?;
    parse_response(response).await
}

async fn parse_response<T>(response: reqwest::Response) -> Result<T>
where
    T: DeserializeOwned,
{
    let status = response.status();
    if status.is_success() {
        response
            .json::<T>()
            .await
            .context("failed to deserialize control API response")
    } else {
        let body = response
            .text()
            .await
            .unwrap_or_else(|_| "<unavailable>".to_string());
        bail!("control API request failed ({status}): {body}");
    }
}

async fn presets_list(client: &Client, base_url: &str) -> Result<()> {
    #[derive(serde::Deserialize)]
    struct PresetList { presets: Vec<String> }
    let url = join_url(base_url, "/api/presets");
    let list: PresetList = client.get(url).send().await?.json().await?;
    if list.presets.is_empty() {
        println!("No presets available");
    } else {
        println!("Available presets:");
        for name in list.presets {
            println!("  - {}", name);
        }
    }
    Ok(())
}

async fn presets_apply(client: &Client, base_url: &str, name: &str) -> Result<()> {
    #[derive(serde::Serialize)]
    struct Apply { name: String }
    let url = join_url(base_url, "/api/presets/apply");
    let body = Apply { name: name.to_string() };
    let snapshot: ConfigSnapshot = client.post(url).json(&body).send().await?.json().await?;
    println!("Applied preset '{}' at tick {}", name, snapshot.tick);
    Ok(())
}

fn join_url(base: &str, path: &str) -> String {
    let base = base.trim_end_matches('/');
    if path.starts_with('/') {
        format!("{base}{path}")
    } else {
        format!("{base}/{path}")
    }
}

fn parse_value(raw: &str) -> Result<Value> {
    match serde_json::from_str::<Value>(raw) {
        Ok(value) => Ok(value),
        Err(_) => Ok(Value::String(raw.to_string())),
    }
}

fn knob_kind_label(kind: KnobKind) -> &'static str {
    match kind {
        KnobKind::Number => "number",
        KnobKind::Integer => "integer",
        KnobKind::Boolean => "bool",
        KnobKind::String => "string",
        KnobKind::Array => "array",
        KnobKind::Object => "object",
        KnobKind::Null => "null",
    }
}

fn value_to_string(value: &Value, max_len: usize) -> String {
    let raw = match value {
        Value::String(s) => format!("\"{}\"", s),
        other => serde_json::to_string(other).unwrap_or_else(|_| "<error>".to_string()),
    };
    if raw.len() > max_len {
        format!("{}â€¦", &raw[..max_len.saturating_sub(1)])
    } else {
        raw
    }
}

fn json_pointer(path: &str) -> String {
    let mut pointer = String::from("/");
    pointer.push_str(&path.replace('.', "/"));
    pointer
}
